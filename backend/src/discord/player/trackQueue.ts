import { QueueItem, Track } from './types.js';
import { DatabaseService } from './databaseService.js';
import { PlayerStateManager } from './playerStateManager.js';
import { CacheManager } from './cacheManager.js';
import { BlockedContentManager } from './blockedContentManager.js'; // To check blocked status

export class TrackQueue {
  private userQueue: QueueItem[] = [];
  private autoplayQueue: QueueItem[] = [];
  private databaseService: DatabaseService;
  private playerStateManager: PlayerStateManager;
  private cacheManager: CacheManager;
  private blockedContentManager: BlockedContentManager;
  private readonly MAX_QUEUE_LENGTH = parseInt(process.env.MAX_QUEUE_LENGTH || '100'); // Example limit

  constructor(
    databaseService: DatabaseService,
    playerStateManager: PlayerStateManager,
    cacheManager: CacheManager,
    blockedContentManager: BlockedContentManager
  ) {
    this.databaseService = databaseService;
    this.playerStateManager = playerStateManager;
    this.cacheManager = cacheManager;
    this.blockedContentManager = blockedContentManager;

    // Initialize queue from state manager? Or assume state manager starts empty?
    // Let's assume state manager starts empty and TrackQueue manages the source lists.
    this.updateStateManagerQueue();
  }

  // --- Queue Management ---

  /** Adds a track requested by a user. */
  async addTrack(track: QueueItem): Promise<{ success: boolean; reason?: string; position?: number }> {
    console.log(`[TQ] Attempting to add user track: ${track.title}`);
    if (this.isFull()) {
      return { success: false, reason: 'Queue is full.' };
    }
    if (this.isTrackInQueue(track.youtubeId)) {
       console.log(`[TQ] Track ${track.title} is already in the queue.`);
      // Optionally return the existing position? For now, just reject duplicate add.
      return { success: false, reason: 'Track is already in the queue.' };
    }
     if (await this.blockedContentManager.isBlocked(track.youtubeId)) {
       console.log(`[TQ] Cannot add blocked track: ${track.title}`);
       return { success: false, reason: 'This track is currently blocked.' };
     }

    this.userQueue.push(track);
    const position = this.userQueue.length -1; // Position in user queue
    console.log(`[TQ] Added user track ${track.title} at position ${position}`);
    this.updateStateManagerQueue();
    this.prefetchNextTracks(); // Trigger prefetch
    return { success: true, position: this.getFullQueuePosition(track.youtubeId) };
  }

  /** Adds a track generated by autoplay. */
  async addAutoplayTrack(track: QueueItem): Promise<boolean> {
    console.log(`[TQ] Attempting to add autoplay track: ${track.title}`);
    // Autoplay queue might have different size limits if needed
    if (this.isFull()) { // Use overall limit for now
        console.warn('[TQ] Queue is full, cannot add autoplay track.');
        return false;
    }
    if (this.isTrackInQueue(track.youtubeId)) {
      console.log(`[TQ] Autoplay track ${track.title} is already in the queue.`);
      return false; // Don't add duplicates
    }
     if (await this.blockedContentManager.isBlocked(track.youtubeId)) {
       console.log(`[TQ] Cannot add blocked autoplay track: ${track.title}`);
       return false;
     }

    this.autoplayQueue.push(track);
    console.log(`[TQ] Added autoplay track ${track.title}`);
    this.updateStateManagerQueue();
    this.prefetchNextTracks(); // Trigger prefetch
    return true;
  }

  /** Gets the next track to play, prioritizing the user queue. */
  getNextTrack(): QueueItem | null {
    let nextTrack: QueueItem | undefined;

    if (this.userQueue.length > 0) {
      nextTrack = this.userQueue.shift();
      console.log(`[TQ] Getting next track from user queue: ${nextTrack?.title}`);
    } else if (this.autoplayQueue.length > 0) {
      nextTrack = this.autoplayQueue.shift();
      console.log(`[TQ] Getting next track from autoplay queue: ${nextTrack?.title}`);
    } else {
      console.log('[TQ] No tracks in queue.');
      return null;
    }

    if (nextTrack) {
      this.updateStateManagerQueue();
      // Check if we need to fill the autoplay buffer after taking a track
      const totalQueueLength = this.userQueue.length + this.autoplayQueue.length;
      if (totalQueueLength < 5) { // Use 5 as the minimum threshold
        console.log(`[TQ] Queue length (${totalQueueLength}) below threshold, triggering autoplay fill...`);
        this.playerStateManager.triggerAutoplayFill();
      }
      return nextTrack;
    }
    return null;
  }

  /** Removes a track from the queue by its position in the combined queue. */
  removeTrackAt(position: number): QueueItem | null {
    console.log(`[TQ] Attempting to remove track at combined position ${position}`);
    if (position < 0) return null;

    let removedTrack: QueueItem | null = null;

    if (position < this.userQueue.length) {
      // Remove from user queue
      removedTrack = this.userQueue.splice(position, 1)[0];
      console.log(`[TQ] Removed track from user queue: ${removedTrack?.title}`);
    } else {
      // Adjust position for autoplay queue
      const autoplayPosition = position - this.userQueue.length;
      if (autoplayPosition < this.autoplayQueue.length) {
        removedTrack = this.autoplayQueue.splice(autoplayPosition, 1)[0];
        console.log(`[TQ] Removed track from autoplay queue: ${removedTrack?.title}`);
      } else {
          console.log(`[TQ] Invalid position ${position}, queue length ${this.getLength()}`);
      }
    }

    if (removedTrack) {
      this.updateStateManagerQueue();
    }
    return removedTrack;
  }

  /** Clears both user and autoplay queues. */
  clearQueue(): void {
    console.log('[TQ] Clearing all queues.');
    this.userQueue = [];
    this.autoplayQueue = [];
    this.updateStateManagerQueue();
  }

  /** Gets the combined queue (user + autoplay). */
  getCombinedQueue(): QueueItem[] {
    return [...this.userQueue, ...this.autoplayQueue];
  }

  /** Gets the current length of the combined queue. */
  getLength(): number {
    return this.userQueue.length + this.autoplayQueue.length;
  }

  /** Checks if the combined queue is full. */
  isFull(): boolean {
    return this.getLength() >= this.MAX_QUEUE_LENGTH;
  }

  // --- Utility Methods ---

  /** Checks if a track (by ID) is already in either queue or currently playing. */
  private isTrackInQueue(youtubeId: string): boolean {
     const currentTrack = this.playerStateManager.getCurrentTrack();
     if (currentTrack?.youtubeId === youtubeId) {
         return true;
     }
    return this.userQueue.some(track => track.youtubeId === youtubeId) ||
           this.autoplayQueue.some(track => track.youtubeId === youtubeId);
  }

  /** Gets the position of a track in the combined queue. Returns -1 if not found. */
  private getFullQueuePosition(youtubeId: string): number {
      const userIndex = this.userQueue.findIndex(t => t.youtubeId === youtubeId);
      if (userIndex !== -1) {
          return userIndex;
      }
      const autoplayIndex = this.autoplayQueue.findIndex(t => t.youtubeId === youtubeId);
      if (autoplayIndex !== -1) {
          return this.userQueue.length + autoplayIndex;
      }
      return -1;
  }


  /** Updates the PlayerStateManager with the current combined queue. */
  private updateStateManagerQueue(): void {
    this.playerStateManager.setQueue(this.getCombinedQueue());
  }

  /** Prefetches audio for the next few tracks in the combined queue. */
  private prefetchNextTracks(count: number = 3): void {
      const combinedQueue = this.getCombinedQueue();
      const tracksToPrefetch = combinedQueue.slice(0, count);
      console.log(`[TQ] Prefetching next ${tracksToPrefetch.length} tracks.`);
      tracksToPrefetch.forEach(track => {
          // Use CacheManager to handle prefetching
          this.cacheManager.prefetchAudio(track.youtubeId);
      });
  }

   // --- Cleanup ---
   public destroy(): void {
       console.log('[TQ] Destroying TrackQueue...');
       this.userQueue = [];
       this.autoplayQueue = [];
       // No intervals or listeners to clear in this class itself
       console.log('[TQ] TrackQueue destroyed.');
   }
}